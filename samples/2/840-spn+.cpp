#pragma once
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<memory.h>
#include<time.h>
#include<assert.h>

void Encrypt(unsigned char state[4][4], unsigned char k[16]);
void Decrypt(unsigned char state[4][4], unsigned char k[16]);
void ExpandKey(unsigned char k[16], unsigned w[44]);
void AddRoundKey(unsigned char state[4][4], unsigned w[4]);
void PMove(unsigned char state[4][4]);
void PMove_1(unsigned char state[4][4]);
void ByteSub(unsigned char state[4][4]);
void ByteSub_1(unsigned char state[4][4]);
unsigned SubWord(unsigned dst);
unsigned Rotwrod(unsigned dst);
unsigned char GetSByte(unsigned char byte);
void BuildTxt();


unsigned char S[16][16] = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

unsigned char S_1[16][16] = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

unsigned RCon[10] = { 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000 };

int P[128] = { 90, 41, 32, 110, 66, 54, 5, 34, 21, 39, 40, 84, 99, 118, 97, 25,
		91, 31, 80, 95, 52, 81, 111, 42, 51, 100, 71, 7, 18, 33, 48, 50,
		16, 114, 105, 126, 60, 61, 83, 56, 15, 88, 12, 23, 67, 11, 92, 125,
		69, 104, 68, 36, 3, 75, 124, 30, 113, 96, 20, 43, 85, 98, 119, 59,
		82, 6, 14, 29, 2, 86, 55, 49, 65, 76, 53, 117, 112, 74, 123, 9,
		44, 35, 38, 115, 108, 73, 57, 19, 22, 37, 17, 45, 78, 58, 107, 28,
		122, 47, 70, 13, 116, 63, 77, 27, 102, 120, 106, 127, 0, 10, 87, 64,
		1, 89, 79, 72, 103, 8, 109, 4, 121, 46, 94, 26, 24, 62, 101, 93 };

int P_1[128] = { 108, 112, 68, 52, 119, 6, 65, 27, 117, 79, 109, 45, 42, 99, 66, 40,
		32, 90, 28, 87, 58, 8, 88, 43, 124, 15, 123, 103, 95, 67, 55, 17,
		2, 29, 7, 81, 51, 89, 82, 9, 10, 1, 23, 59, 80, 91, 121, 97,
		30, 71, 31, 24, 20, 74, 5, 70, 39, 86, 93, 63, 36, 37, 125, 101,
		111, 72, 4, 44, 50, 48, 98, 26, 115, 85, 77, 53, 73, 102, 92, 114,
		18, 21, 64, 38, 11, 60, 69, 110, 41, 113, 0, 16, 46, 127, 122, 19,
		57, 14, 61, 12, 25, 126, 104, 116, 49, 34, 106, 94, 84, 118, 3, 22,
		76, 56, 33, 83, 100, 75, 13, 62, 105, 120, 96, 78, 54, 47, 35, 107 };

	/*-------------------------------------------------密钥编排方案-------------------------------------------------------------------*/
void ExpandKey(unsigned char k[16], unsigned w[44]) {
		unsigned tmp;
		for (int i = 0; i < 4; i++)
			w[i] = ((unsigned)k[i + 3] << 24) + ((unsigned)k[i + 2] << 16) + ((unsigned)k[i + 1] << 8) + (unsigned)k[i + 1];
		for (int i = 4; i < 44; i++) {
			tmp = w[i - 1];
			if (i % 4 == 0)
				tmp = SubWord(Rotwrod(tmp)) ^ RCon[i / 4];
			w[i] = w[i - 4] ^ tmp;
		}
	}
	unsigned SubWord(unsigned dst) {
		unsigned char tmp[4];
		unsigned r;
		for (int i = 0; i < 4; i++) {
			tmp[i] = (dst >> (i * 8)) & 0x0ff;
			tmp[i] = GetSByte(tmp[i]);
		}
		r = (unsigned)tmp[0] + (((unsigned)tmp[1]) << 8) +
			(((unsigned)tmp[2]) << 16) + (((unsigned)tmp[3]) << 24);
		return r;
	}


	unsigned Rotwrod(unsigned dst) {
		unsigned r;
		r = dst << 8 + (unsigned)dst >> 24;
		return r;
	}

	unsigned char GetSByte(unsigned char byte) {
		unsigned char r;
		int row = (int)(byte >> 4) & 0x0f;
		int col = (int)byte & 0x0f;
		r = S[row][col];
		return r;
	}
	/*-------------------------------------------------密钥编排方案-------------------------------------------------------------------*/

void Encrypt(unsigned char state[4][4], unsigned char k[16]) {
		unsigned w[44];
		ExpandKey(k, w);
		for (int i = 0; i < 11; i++) {
			AddRoundKey(state, w + i * 4);

			ByteSub(state);
			if (i == 9) {
				AddRoundKey(state, w + 40);
				break;
			}
			PMove(state);
		}
	}

	void Decrypt(unsigned char state[4][4], unsigned char k[16]) {
		unsigned w[44];
		ExpandKey(k, w);
		AddRoundKey(state, w + 40);
		ByteSub_1(state);
		AddRoundKey(state, w + 36);
		for (int i = 8; i >= 0; i--) {
			PMove_1(state);
			ByteSub_1(state);
			AddRoundKey(state, w + i * 4);
		}
	}

void AddRoundKey(unsigned char state[4][4], unsigned w[4]) {
		unsigned char tmp;
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++) {
				tmp = (w[i] >> (j * 8)) & 0x0ff;
				state[i][j] = state[i][j] ^ tmp;
			}
	}

void ByteSub(unsigned char state[4][4]) {
		int  row, col;
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++) {
				col = (int)state[i][j] & 0x0f;
				row = (int)(state[i][j] >> 4) & 0x0f;
				state[i][j] = S[row][col];
			}
	}

void ByteSub_1(unsigned char state[4][4]) {
		int  row, col;
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++) {
				col = (int)state[i][j] & 0x0f;
				row = (int)(state[i][j] >> 4) & 0x0f;
				state[i][j] = S_1[row][col];
			}
	}

void PMove(unsigned char state[4][4]) {
		bool tmpBool[128], tmpState[128];
		int count;
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				for (int k = 0; k < 8; k++) {
					tmpState[i * 32 + j * 8 + k] = (state[i][j] >> k) & 0x01;
				}
			}
		}
		for (int i = 0; i < 128; i++) {
			tmpBool[i] = tmpState[P[i]];
		}
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				state[i][j] = 0;
				for (int k = 0, count = 1; k < 8; k++, count *= 2) {
					state[i][j] += tmpBool[i * 32 + j * 8 + k] * count;
				}
			}
		}
		return;
	}

void PMove_1(unsigned char state[4][4]) {
		bool tmpBool[128], tmpState[128];
		int count;
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				for (int k = 0; k < 8; k++) {
					tmpState[i * 32 + j * 8 + k] = (state[i][j] >> k) & 0x01;
				}
			}
		}
		for (int i = 0; i < 128; i++) {
			tmpBool[i] = tmpState[P_1[i]];
		}
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				state[i][j] = 0;
				for (int k = 0, count = 1; k < 8; k++, count *= 2) {
					state[i][j] += tmpBool[i * 32 + j * 8 + k] * count;
				}
			}
		}
		return;
	}

void BuildTxt() {
		unsigned char plain[4][4], k[16];
		FILE *fp = fopen("test.txt", "wb+");
		for (int i = 0; i < 16; i++) {
			k[i] = 0;
			plain[i / 4][i % 4] = 0;
		}
		for (int i = 0; i < 640*1024; i++) {
			Encrypt(plain, k);
			fwrite(plain[0], 1, 4, fp);
			fwrite(plain[1], 1, 4, fp);
			fwrite(plain[2], 1, 4, fp);
			fwrite(plain[3], 1, 4, fp);
			for (int j = 0; j < 16; j++) {
				k[j] = plain[j / 4][j % 4];
				plain[j / 4][j % 4] = 0;
			}
		}
		fclose(fp);
	}


int main() {
	SPN_P::BuildTxt();
	bool result[32];
	bool key[32] = {1,0,0,1,0,1,1,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,1};
	unsigned char k[16]{5,10,3,13,4,1,7,11,12,9,7,5,15,8,6,1};
	bool input[16] = { 1,0,0,1,1,0,0,0,1,0,1,1,0,1,0,1 };
	unsigned char state[4][4] = {{'e', 'q', 'r', 't'},
								{'f', 'g', 's', 'f'},
								{'0', 'c', 'g', 'j'},
								{'x', 'l', '.', 'f'},};
	printf("spn_plus:\n");
	for (int i = 0; i < 4; i++) {
		for(int j = 0; j < 4; j++)
			printf("%c", state[i][j]);
		printf(" ");
	}
	printf("\n");
	SPN_P::Encrypt(state, k);
	for (int i = 0; i < 4; i++) {
		for(int j = 0; j < 4; j++)
			printf("%c", state[i][j]);
		printf(" ");
	}
	printf("\n");
	SPN_P::Decrypt(state, k);
	for (int i = 0; i < 4; i++) {
		for(int j = 0; j < 4; j++)
			printf("%c", state[i][j]);
		printf(" ");
	}
	printf("\n");
	return 0;
}