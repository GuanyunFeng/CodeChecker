#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

int K[11][128];  //轮密钥
int SBox[256]={0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x1  ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76 ,
               0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0 ,
               0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15 ,
               0x4  ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x5  ,0x9a ,0x7  ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75 ,
               0x9  ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84 ,
               0x53 ,0xd1 ,0x0  ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf ,
               0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x2  ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8 ,
               0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2 ,
               0xcd ,0xc  ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73 ,
               0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0xb  ,0xdb ,
               0xe0 ,0x32 ,0x3a ,0xa  ,0x49 ,0x6  ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79 ,
               0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x8  ,
               0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a ,
               0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x3  ,0xf6 ,0xe  ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e ,
               0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf ,
               0x8c ,0xa1 ,0x89 ,0xd  ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0xf ,0xb0 ,0x54 ,0xbb  ,0x16};  //S盒

int S_Box[256]={0x52 ,0x9  ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb,
                0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb,
                0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0xb  ,0x42 ,0xfa ,0xc3 ,0x4e,
                0x8  ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25,
                0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92,
                0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84,
                0x90 ,0xd8 ,0xab ,0x0  ,0x8c ,0xbc ,0xd3 ,0xa  ,0xf7 ,0xe4 ,0x58 ,0x5  ,0xb8 ,0xb3 ,0x45 ,0x6 ,
                0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0xf  ,0x2  ,0xc1 ,0xaf ,0xbd ,0x3  ,0x1  ,0x13 ,0x8a ,0x6b,
                0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73,
                0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e,
                0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0xe  ,0xaa ,0x18 ,0xbe ,0x1b,
                0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4,
                0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x7  ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f,
                0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0xd  ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef,
                0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61,
                0x17 ,0x2b ,0x4  ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0xc  ,0x7d};  //S盒的逆


int PBox1[128]={ 0x30, 0x44, 0xd, 0x5f, 0x53, 0x6a, 0x3e, 0x2b, 0x1c, 0x4c, 0x23, 0x1a, 0x2a, 0x4b, 0x69, 0x40, 0x19, 0x26, 0x24, 0x48, 0x59, 0x2, 0x6e, 0x3f, 0x5e, 0x46, 0x12, 0x63, 0x3, 0x70, 0x60, 0x17, 0x5b, 0x6, 0xa, 0x49, 0x1e, 0x9, 0x45, 0x47, 0x16, 0x58, 0x71, 0x39, 0x15, 0x35, 0x14, 0x52, 0x33, 0x31, 0x38, 0x7e, 0x4a, 0x7b, 0x5c, 0x4d, 0x6c, 0x2c, 0x7d, 0x5a, 0x22, 0x4f, 0x62, 0x36, 0x43, 0x29, 0x3b, 0x73, 0x34, 0x64, 0x37, 0x1f, 0x18, 0x1d, 0x51, 0x78, 0x1b, 0x4, 0xb, 0x55, 0x57, 0x61, 0xc, 0x0, 0x56, 0x21, 0x28, 0x42, 0x2d, 0x20, 0x65, 0x76, 0x50, 0x7f, 0x6f, 0x68, 0x2e, 0x67, 0x66, 0x7, 0x5, 0x8, 0x1, 0x25, 0x4e, 0x54, 0x3c, 0x13, 0x2f, 0x75, 0x3d, 0x41, 0x6b, 0x72, 0xf, 0x3a, 0x6d, 0xe, 0x77, 0x7a, 0x7c, 0x32, 0x27, 0x5d, 0x79, 0x74, 0x11, 0x10 };

int PBox[128]={17,33,49,65,81,97,113,1,
               18,34,50,66,82,98,114,2,
               19,35,51,67,83,99,115,3,
               20,36,52,68,84,100,116,4,
               21,37,53,69,85,101,117,5,
               22,38,54,70,86,102,118,6,
               23,39,55,71,87,103,119,7,
               24,40,56,72,88,104,120,8,
               25,41,57,73,89,105,121,9,
               26,42,58,74,90,106,122,10,
               27,43,59,75,91,107,123,11,
               28,44,60,76,92,108,124,12,
               29,45,61,77,93,109,125,13,
               30,46,62,78,94,110,126,14,
               31,47,63,79,95,111,127,15,
               32,48,64,80,96,112,128,16};
int P_Box[128]={8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,
                1, 9,17,25,33,41,49,57,65,73,81,89, 97,105,113,121,
                2,10,18,26,34,42,50,58,66,74,82,90, 98,106,114,122,
                3,11,19,27,35,43,51,59,67,75,83,91, 99,107,115,123,
                4,12,20,28,36,44,52,60,68,76,84,92,100,108,116,124,
                5,13,21,29,37,45,53,61,69,77,85,93,101,109,117,125,
                6,14,22,30,38,46,54,62,70,78,86,94,102,110,118,126,
                7,15,23,31,39,47,55,63,71,79,87,95,103,111,119,127};  //P盒的逆
int InitialKey[16]={0};//密钥为128bit的0,每个数组元素存储1个字节
int x[128]={0};//明文全0

int Arraytonum(int *y)//将二进制数组转化为整型
{
    int i,n;
    n=y[0];
    for(i=0;i<15;i++)
    {
        n=n*2+y[i+1];
    }
    return n;
}

unsigned int Arrayitonum(int *y,int i)//将i位二进制数组转化为整型
{
    int k;
    unsigned int n;
    n=y[0];
    for(k=0;k<i-1;k++)
    {
        n=n*2+y[k+1];
    }
    return n;
}

int numtoArrayi(unsigned int num,int *a,int i)
{
    int k;
    for(k=0;k<i;k++)
    {
        a[i-1-k]=num%2;
        num/=2;
    }
    return a[0];
}

void KeyExpansion(int *key,unsigned int *w)
{
    int i,temp;
    int B[4];
    unsigned int Rcon[10];
    Rcon[0]=0x01000000;
    Rcon[1]=0x02000000;
    Rcon[2]=0x04000000;
    Rcon[3]=0x08000000;
    Rcon[4]=0x10000000;
    Rcon[5]=0x20000000;
    Rcon[6]=0x40000000;
    Rcon[7]=0x80000000;
    Rcon[8]=0x1B000000;
    Rcon[9]=0x36000000;
    for(i=0;i<4;i++)
	{
		w[i]=(key[4*i]>>24)+(key[4*i+1]>>16)+(key[4*i+2]>>8)+key[4*i+3];
	}
	for(i=4;i<44;i++)
	{
		temp=w[i-1];
		if(i%4==0)
		{
			temp=(temp<<8|temp>> 24);//循环左移一个字节,RotWord
			B[3]=temp&0x000000ff;
			B[2]=(temp&0x0000ff00)>>8;
			B[1]=(temp&0x00ff0000)>>16;
			B[0]=(temp&0xff000000)>>24;
			temp=(SBox[B[0]]&0xff000000)+(SBox[B[1]]&0x00ff0000)+(SBox[B[2]]&0x0000ff00)+SBox[B[0]];//SubWord
			temp=temp^Rcon[i/4-1];
		}
		w[i]=w[i-1]^temp;
	}
}

int encryptSPN(int *x,int *y,int *InitialKey)
{
    int i,j,r;
    int X[16],w[16],u[16],v[16];
    int key[16],temp[128],temp1[128];
    unsigned int W[44];//每一个轮密钥由4个字组成，轮密钥的并联即扩展密钥包含44个字
    //轮密钥编排方案
    for(i=0;i<16;i++)
    {
        key[i]=InitialKey[i];
    //    printf("%x\n%d\n",key[i],i);
    }
    KeyExpansion(key,W);
    for(i=0;i<16;i++)
    {
        X[i]=Arrayitonum(x+8*i,8);
        w[i]=X[i];
    }
    for(r=0;r<9;r++)
    {
        for(i=0;i<4;i++)
        {
            for(j=0;j<4;j++)
            {
                u[4*i+j]=(w[4*i+j])^((W[i+4*r]>>(24-8*j))&0xff);
            }
        }
        for(i=0;i<16;i++)
        {
            v[i]=SBox[u[i]];
        }
        for(i=0;i<16;i++)
        {
            numtoArrayi(v[i],temp+8*i,8);
        }
        for(j=0;j<128;j++)
        {
            temp1[j]=temp[j];
        }
        for(j=0;j<128;j++)
        {
            temp[j]=temp1[PBox[j]-1];
        //temp[j]=temp1[PBox[j]];
        }
        for(i=0;i<16;i++)
        {
            w[i]=Arrayitonum(temp+8*i,8);
        }
    }
    //最后一轮
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            u[4*i+j]=(w[4*i+j])^((W[i+36]>>(24-8*j))&0xff);
        }
    }
    for(i=0;i<16;i++)
    {
        v[i]=SBox[u[i]];
    }
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            y[4*i+j]=(v[4*i+j])^((W[i+40]>>(24-8*j))&0xff);
      //      printf("%d ",y[4*i+j]);
        }
    }
    return y[0];

}

int decryptSPN(int *x,int *y,int *InitialKey)
{
    int i,j,r;
    int X[16],w[16],u[16],v[16];
    int key[16],temp[128],temp1[128];
    unsigned int W[44];//每一个轮密钥由4个字组成，轮密钥的并联即扩展密钥包含44个字
    //轮密钥编排方案
    for(i=0;i<16;i++)
    {
        key[i]=InitialKey[i];
    //    printf("%x\n%d\n",key[i],i);
    }
    KeyExpansion(key,W);
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            v[4*i+j]=(y[4*i+j])^((W[i+40]>>(24-8*j))&0xff);
      //      printf("%d",y[4*i+j]);
        }
    }
    for(i=0;i<16;i++)
    {
        u[i]=S_Box[v[i]];
    }
    for(r=9;r>0;r--)
    {
        for(i=0;i<4;i++)
        {
            for(j=0;j<4;j++)
            {
                w[4*i+j]=(u[4*i+j])^((W[i+4*r]>>(24-8*j))&0xff);
            }
        }

        for(i=0;i<16;i++)
        {
            numtoArrayi(w[i],temp+8*i,8);
        }
        for(j=0;j<128;j++)
        {
            temp1[j]=temp[j];
        }
        for(j=0;j<128;j++)
        {
            temp[j]=temp1[P_Box[j]-1];
        //temp[j]=temp1[PBox[j]];
        }
        for(i=0;i<16;i++)
        {
            v[i]=Arrayitonum(temp+8*i,8);
        }
        for(i=0;i<16;i++)
        {
            u[i]=S_Box[v[i]];
        }
    }
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            w[4*i+j]=(u[4*i+j])^((W[i]>>(24-8*j))&0xff);
        }
    }
    for(i=0;i<16;i++)
    {
        X[i]=w[i];
        numtoArrayi(X[i],x+8*i,8);
    }
    return x[0];
}

int main()
{
    int i,n;
    int ciphertext[16];
    int y[128];
    char output[17];
/*文件读
    FILE *plain;
    unsigned char plainBlock[17];
    int X[128];
    if((plain=fopen("plain.txt","rb"))==NULL)
    {
        fprintf(stderr,"Can not open plain.txt file.\n");
        return 0;
    }
    fseek(plain,0,SEEK_END);
    int len=ftell(plain);
    printf("%d\n",len);
    rewind(plain);
    while(!feof(plain))
    {
        fread(plainBlock,1,len,plain);//每次读16个字节,并返回成功读取的字节数
        plainBlock[16]='\0';
        for(i=0;i<16;i++)
        {
            printf("%x",plainBlock[i]);
        }
        printf("\n");
        for(i=0;i<16;i++)
        {
            numtoArrayi(plainBlock[i],X+8*i,8);
        }
        for(i=0;i<128;i++)
        {
            X[i]=X[i];
        }
        encryptSPN(X,ciphertext,InitialKey);
    }
    fclose(plain);
    printf("\n");
*/
    FILE *cipher;
    if((cipher=fopen("cipher.txt","w"))==NULL)
    {
        fprintf(stderr,"Can not open cipher.txt file.\n");
        return 0;
    }
    for(n=0;n<700000;n++)
    {
  //  printf("\n输出密文：\n");
        encryptSPN(x,ciphertext,InitialKey);
        for(i=0;i<16;i++)
        {
            numtoArrayi(ciphertext[i],y+8*i,8);
  //          printf("%d ",ciphertext[i]);
        }
        printf("\n");
        for(i=0;i<128;i++)
        {
  //          printf("%d",y[i]);
            x[i]=y[i];
        }
        //memcpy(output,ciphertext,16);
        for(i=0;i<16;i++)
        {
            output[i]=(char)(ciphertext[i]);
        }
        output[16]='\0';
        fwrite(output,1,16,cipher);
    }
    fclose(cipher);
    printf("\n");
    return 0;
}
